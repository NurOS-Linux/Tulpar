/* NurOS/Tulpar/utils.cpp ruzen42 */
#include "utils.hpp"
#include "../colors.hpp"
#include "../parse_json/parse_json.hpp"

#include <iostream>
#include <iomanip>
#include <filesystem>
#include <unistd.h>
#include <nlohmann/json.hpp>
#include <fstream>
#include <openssl/md5.h>

using namespace parse_json;

namespace utils
{

std::string compute_MD5_from_file(const std::string &filePath)
 {
ifstream file(filePath, ios::in | ios::binary | ios::ate);
   
   if (!file.is_open())
   {
   std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "Cannot open file: " << filePath << "\n";
   return;
   }
   
   long fileSize = file.tellg();
   
   char *memBlock = new char[fileSize];
   
   file.seekg(0, ios::beg);
   file.read(memBlock, fileSize);
   file.close();
   
   unsigned char result[MD5_DIGEST_LENGTH];
   MD5((unsigned char *)memBlock, fileSize, result);
   
   delete[] memBlock;
   
   std::string output;
   
   for (int i = 0; i < size; i++)
   {
   output += std::hex + std::setw(2) + std::setfill('0') + (int)md[i];
   }
   
   return output;
   }


void create_list()
{
    if (!std::filesystem::exists("/var/lib/tulpar"))
    {
        std::filesystem::create_directory("/var/lib/tulpar");
    }

    try 
    {
      std::ofstream list("/var/lib/tulpar/list.json");
      std::ofstream list_installed("/var/lib/tulpar/list_installed.json");
    }
    catch (std::filesystem::filesystem_error err)
    {
      std::cout << COLOR_RED << "Error: " << COLOR_RESET << err.what() << "\n";
      return;
    }

    std::cout << COLOR_GREEN << "Finished: " << COLOR_RESET << "lists created\n";
}

void add_package_to_list(std::string& pkg)
{
    if (!std::filesystem::exists("/var/lib/tulpar/list.json"))
    {
        create_list();
    }

    nlohmann::json json_array = nlohmann::json::array();
    std::ofstream file("/var/lib/tulpar/list_installed.json");

    if (!file.is_open())
    {
      std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "error with opening file\n";
      return;
    }

    file << json_array;

    file.close();

    if (!json_array.is_array()) 
    {
        json_array = nlohmann::json::array();
    }

    json_array.push_back(pkg);

    std::ofstream output_file("/var/lib/tulpar/list_installed.json");
    if (output_file.is_open()) 
    {
        output_file << json_array.dump(4); // 4 spaces  
        output_file.close();
    }
}

void check_root()
{
    auto username = geteuid();

    if (username != 0)
    {
        std::cout << COLOR_RED << "Error: " << COLOR_RESET << "Permission denied\n";
        std::exit(3);
    }
}

std::string find_name_package(std::string file)
{
    std::string name;

    for (unsigned int i = 0; i <= file.length(); ++i)
    {
        if (file[i] == '-')
        {
            break;
        }
        name += file[i];
    }

    return name;
}

void install_local_package(const std::string& file, const std::string& rootfs)
{
    const auto filename = std::filesystem::absolute(file);
    auto name = find_name_package(file);

    if (!std::filesystem::exists(filename))
    {
        std::cout << COLOR_RED << "Error: " << COLOR_RESET << "file not exists\n";
        return;
    }


    if (!std::filesystem::exists("/tmp/tulpar/"))
    {
        std::filesystem::create_directory("/tmp/tulpar/");
    }

    if (!std::filesystem::exists("/tmp/tulpar/" + name))
    {
        std::filesystem::create_directory("/tmp/tulpar/" + name);
    }

    try
    {
        if (!std::filesystem::exists("/tmp/tulpar/" + file))
        {
            std::filesystem::copy(filename, "/tmp/tulpar");
        }
    }
    catch (const std::filesystem::filesystem_error& err)
    {
        std::cout << COLOR_RED << "Error: " << COLOR_RESET << err.what() << "\n";
        return;
    }

    try
    {
      // Deprecated:
      std::cout << "Extracting tar archive to /tmp/tulpar/ + name 
      system(("tar xvf /tmp/tulpar/" + file + " -C /tmp/tulpar/" + name + " >> /dev/null").c_str());
    }
    catch (std::system_error err)
    {
        std::cout << COLOR_RED << "Error: " << COLOR_RESET << err.what() << "\n";
        return;
    }

    utils::package data_package = parse_file("/tmp/tulpar/" + name + "/metadata.json");
    auto pkg_name = data_package.name; 

    std::cout << COLOR_GREEN << "Finished: " << COLOR_RESET << "Extracting tar archive\n";

    check_root();
    std::cout << "Package to be installed: " << COLOR_GREEN << pkg_name + " " << COLOR_RESET << " \n";

    char answer;
    std::cout << "Proceed install package " + name + "? [" 
      << COLOR_GREEN << "Y" << COLOR_RESET << "/" << COLOR_RED << "n" << COLOR_RESET << "] ";

    std::cin >> answer;
  
    if (std::tolower(answer) == 'n')
    {
        std::cout << "Cancel installation" << "\n";
        return;
    }
    try 
    {
      std::cout << "Installing package\n";
      std::filesystem::copy("/tmp/tulpar/" + name + "/data/", rootfs, std::filesystem::copy_options::recursive);
    }
    catch (std::filesystem::filesystem_error err)
    {
        std::cout << COLOR_RED << "Error: " << COLOR_RESET << err.what() << "\n";
    }

    std::cout << COLOR_GREEN << "Finished: " << COLOR_RESET << "Installed with Success\n";
}

void install_package(const std::string& pkg)
{
    check_root();
    if (pkg.empty())
    {
        std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "Package name cannot be empty" << "\n";
        return;
    }
    std::cout << COLOR_GREEN << "" << pkg << "\n";
}

void remove_package(const std::string& pkg)
{
    check_root();
    if (pkg.empty())
    {
        std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "Package name cannot be empty" << "\n";
        return;
    }
    std::cout << COLOR_GREEN << "Good" << pkg << "\n";
}

void update_package(const std::string& pkg)
{
    check_root();
    if (pkg.empty())
    {
        std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "Package name cannot be empty" << "\n";
        return;
    }
    std::cout << COLOR_GREEN << "Good" << pkg << "\n";
}

void search_package(const std::string& pkg)
{
    if (pkg.empty())
    {
        std::cerr << COLOR_RED << "Error: " << COLOR_RESET << "Package name cannot be empty" << "\n";
        return;
    }
    std::cout << COLOR_GREEN << "Good" << pkg << "\n";
}

void clean_cache()
{
    check_root();
    std::cout << COLOR_GREEN << "Cleaning..." << COLOR_RESET << "\n";
    if (std::filesystem::exists("/tmp/tulpar") ||  std::filesystem::exists("/var/cache/tulpar"))
    {
        try
        {
            std::cout <<  "Removing /tmp/tulpar" << "\n";
            std::filesystem::remove_all("/tmp/tulpar/");
            std::cout <<  "Removing /var/cache/tulpar" << "\n";
            std::filesystem::remove_all("/var/cache/tulpar/");
        }
        catch (std::filesystem::filesystem_error err)
        {
            std::cout << COLOR_RED << "Error with cleaning: " << COLOR_RESET << err.what() << "\n";
            return;
        }
    }
    std::cout << COLOR_GREEN << "All done without errors" << COLOR_RESET << "\n";
}
}
